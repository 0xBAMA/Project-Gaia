// Generated by CoffeeScript 1.10.0
(function() {
  'use strict';
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ProjectGaia.VoxelMesh = (function(superClass) {
    extend(VoxelMesh, superClass);

    function VoxelMesh(options) {
      var blockCoordinatesArray, blockCoordinatesAttribute, blockIndex, blockOffset, blocksCount, depth, geometry, height, i, index, indicesArray, indicesArrayLength, indicesAttribute, indicesPerBlock, indicesPerSide, j, k, l, m, n, normal, normalAttribute, normalsArray, o, p, positionAttribute, positionsArray, q, r, ref, ref1, ref2, ref3, ref4, ref5, s, side, t, vertexArraysLength, verticesOffset, verticesPerBlock, verticesPerSide, width, x, y, z;
      this.options = options;
      width = this.options.width;
      height = this.options.height;
      depth = this.options.depth;
      blocksCount = width * height * depth;
      verticesPerSide = 4;
      verticesPerBlock = verticesPerSide * 6;
      indicesPerSide = 6;
      indicesPerBlock = indicesPerSide * 6;
      vertexArraysLength = blocksCount * verticesPerBlock * 3;
      positionsArray = new Float32Array(vertexArraysLength);
      normalsArray = new Float32Array(vertexArraysLength);
      blockCoordinatesArray = new Uint8Array(vertexArraysLength);
      for (z = k = 0, ref = depth; 0 <= ref ? k < ref : k > ref; z = 0 <= ref ? ++k : --k) {
        for (y = l = 0, ref1 = height; 0 <= ref1 ? l < ref1 : l > ref1; y = 0 <= ref1 ? ++l : --l) {
          for (x = m = 0, ref2 = width; 0 <= ref2 ? m < ref2 : m > ref2; x = 0 <= ref2 ? ++m : --m) {
            blockOffset = this.options.world.getBlockIndexForCoordinates(x, y, z) * verticesPerBlock * 3;
            for (side = n = 0; n <= 5; side = ++n) {
              for (j = o = 0; o <= 1; j = ++o) {
                for (i = p = 0; p <= 1; i = ++p) {
                  index = blockOffset + (i + j * 2 + side * 4) * 3;
                  this.createVertexForSide(positionsArray, index, side, x, y, z, i, j);
                  normal = ProjectGaia.Sides.Normals[side];
                  normalsArray[index] = normal.x;
                  normalsArray[index + 1] = normal.y;
                  normalsArray[index + 2] = normal.z;
                  blockCoordinatesArray[index] = x;
                  blockCoordinatesArray[index + 1] = y;
                  blockCoordinatesArray[index + 2] = z;
                }
              }
            }
          }
        }
      }
      indicesArrayLength = blocksCount * indicesPerBlock;
      indicesArray = new Uint32Array(indicesArrayLength);
      for (z = q = 0, ref3 = depth; 0 <= ref3 ? q < ref3 : q > ref3; z = 0 <= ref3 ? ++q : --q) {
        for (y = r = 0, ref4 = height; 0 <= ref4 ? r < ref4 : r > ref4; y = 0 <= ref4 ? ++r : --r) {
          for (x = s = 0, ref5 = width; 0 <= ref5 ? s < ref5 : s > ref5; x = 0 <= ref5 ? ++s : --s) {
            blockIndex = this.options.world.getBlockIndexForCoordinates(x, y, z);
            blockOffset = blockIndex * indicesPerBlock;
            for (side = t = 0; t <= 5; side = ++t) {
              index = blockOffset + side * indicesPerSide;
              verticesOffset = blockIndex * verticesPerBlock + side * verticesPerSide;
              indicesArray[index] = verticesOffset;
              indicesArray[index + 1] = verticesOffset + 1;
              indicesArray[index + 2] = verticesOffset + 3;
              indicesArray[index + 3] = verticesOffset;
              indicesArray[index + 4] = verticesOffset + 3;
              indicesArray[index + 5] = verticesOffset + 2;
            }
          }
        }
      }
      geometry = new THREE.BufferGeometry();
      positionAttribute = new THREE.BufferAttribute(positionsArray, 3);
      normalAttribute = new THREE.BufferAttribute(normalsArray, 3);
      blockCoordinatesAttribute = new THREE.BufferAttribute(blockCoordinatesArray, 3);
      geometry.setAttribute("position", positionAttribute);
      geometry.setAttribute("normal", normalAttribute);
      geometry.setAttribute("blockCoordinates", blockCoordinatesAttribute);
      indicesAttribute = new THREE.BufferAttribute(indicesArray, 1);
      geometry.setIndex(indicesAttribute);
      VoxelMesh.__super__.constructor.call(this, geometry, this.options.material);
    }

    VoxelMesh.prototype.createVertexForSide = function(array, index, side, x, y, z, i, j) {
      var rx, ry, rz;
      rx = x;
      ry = y;
      rz = z;
      switch (side) {
        case ProjectGaia.Sides.Right:
          rx++;
          ry += j;
          rz -= i;
          break;
        case ProjectGaia.Sides.Left:
          ry += j;
          rz -= 1 - i;
          break;
        case ProjectGaia.Sides.Up:
          rx += i;
          ry++;
          rz -= j;
          break;
        case ProjectGaia.Sides.Down:
          rx += i;
          rz += j - 1;
          break;
        case ProjectGaia.Sides.Forward:
          rx += 1 - i;
          ry += j;
          rz--;
          break;
        case ProjectGaia.Sides.Back:
          rx += i;
          ry += j;
      }
      array[index] = rx;
      array[index + 1] = ry;
      return array[index + 2] = rz;
    };

    return VoxelMesh;

  })(THREE.Mesh);

}).call(this);

//# sourceMappingURL=voxelmesh.js.map
